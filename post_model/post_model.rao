import java.util.Arrays

enum OperatorState {free, busy}
enum WindowState {open, close, in_postwork}
enum TypeService {send_letter, receive_letter, send_delivery, receive_delivery}
enum ClientState {enter, start_service}

constant send_letter_time = 4.0;
constant receive_letter_time = 12.0;
constant send_delivery_time = 15.0;
constant receive_delivery_time = 10.0;

type PostDepartment {
	int queLength;		
}

type Client {	
	int id;
	TypeService service;
	ClientState state;
	double enterTime;
}

type Window {
	WindowState windowState;
	OperatorState operatorState;
	int servedPeopleAll;	
	TypeService[] service;
	SheduleDay[] shedule;
	double postTime;
	double queueTimeAll;
}

type SheduleDay {
	int timeStart = 8;
	int timeEnd = 20;
}

resource fullDay = new SheduleDay(8, 19);
resource close = new SheduleDay(0, 0);
resource firstHalf = new SheduleDay(8, 14);
resource secondHalf = new SheduleDay(14, 19);
 
sequence clientEnterInterval = new Uniform(123456789, 10, 50);//new Exponential(123456789, 1/30.0);
sequence serviceDuration = new Uniform(123456789, 10, 50);
sequence randomTypeService = new DiscreteHistogram<TypeService>(123456789,
	#[TypeService.send_letter -> 5.0, TypeService.receive_letter -> 1.0, TypeService.send_delivery -> 2.0, TypeService.receive_delivery -> 3.0]);

resource post = PostDepartment.create(0);

resource window1 = Window.create(WindowState.close, OperatorState.free, 0, 
	Arrays.asList(TypeService.send_letter, TypeService.receive_letter),
	Arrays.asList(close, firstHalf, close, fullDay, secondHalf, close, firstHalf), 0, 0
); 
resource window2 = Window.create(WindowState.close, OperatorState.free, 0, 
	Arrays.asList(TypeService.send_letter, TypeService.receive_letter),
	Arrays.asList(fullDay, firstHalf, close, close, firstHalf, firstHalf, close), 0, 0
);
resource window3 = Window.create(WindowState.close, OperatorState.free, 0, 
	Arrays.asList(TypeService.send_delivery, TypeService.receive_delivery),
	Arrays.asList(secondHalf, firstHalf, fullDay, close, firstHalf, firstHalf, close), 0, 0
);

event ClientEnterEvent() {
	var id = Client.all.size;
	post.queLength = post.queLength + 1;
	Client.create(id, randomTypeService.next(), ClientState.enter, currentTime);	
	ClientEnterEvent.plan(currentTime + clientEnterInterval.next());
	
}

event EveryHourEvent() {
	EveryHourEvent.plan(currentTime + 60);
	var windows = Window.accessible;
	
	for (var j =0; j < windows.length; j++) {
		var window = windows.get(j);
		
		if ( isWindowOpen(window)) {			
			window.windowState = WindowState.open;
		}
		else if(window.windowState == WindowState.open){
			window.windowState = WindowState.in_postwork;
			log(window.windowState);
			CloseWindowEvent.plan(currentTime + (window.postTime as int), window);
		}
	}
}

event CloseWindowEvent(Window win) {
	win.windowState = WindowState.close;
	log('window_closed');
	log(win.postTime as int);
	win.postTime = 0;	
}

// At the end of day post closes and there are no clients
event EndOfDayEvent() {
	var clients = Client.accessible;
	
	log(currentTime);
	log(currentTime % 12);
	for (var i = 0; i < clients.length; i++) {
		var client = clients.get(i);		
		if ( client.state == ClientState.enter ) {
			client.erase();
			post.queLength = post.queLength - 1;			
		}	
	}
	EndOfDayEvent.plan(currentTime + 12 * 60);
}

operation ExampleClientService() {
	relevant _post = post.onlyif[ queLength > 0 ]	
//	relevant _client = Client.all.filter[ state == ClientState.enter ].any;
//	relevant _window = Window.all.filter[ windowState == WindowState.open && operatorState == OperatorState.free
//			&&  service.contains(_client.service) ].minBySafe[ servedPeopleAll ];
	relevant _window = Window.all.filter[ windowState == WindowState.open && operatorState == OperatorState.free].minBySafe[ servedPeopleAll ];
	relevant _client = Client.all.filter[ state == ClientState.enter && _window.service.contains(service) ].minBySafe[ id ];				
	
	def duration() {
		return getDuration(_client);
	}
	
	def begin() {
		_post.queLength = _post.queLength - 1;
		_client.state = ClientState.start_service;
		_window.operatorState = OperatorState.busy	
		_window.queueTimeAll = _window.queueTimeAll + (currentTime - _client.enterTime);	
	}
	
	def end() {		 
		_window.operatorState = OperatorState.free;					
		_window.servedPeopleAll = _window.servedPeopleAll + 1;
		_window.postTime = _window.postTime + getDuration(_client) * 0.2;		
		_client.erase();
	}
}

logic Model {
	activity clientService = new Activity(ExampleClientService.create());
}

def init() {
	ClientEnterEvent.plan(currentTime + clientEnterInterval.next());
	EveryHourEvent.plan(currentTime);	
	EndOfDayEvent.plan(currentTime + 12 * 60 - 2 );
}

def terminateCondition() {
	return currentTime >= 7 * 12 * 60;
}

boolean isWindowOpen(Window window) {	
	var currentDay =  (currentTime / 60 / 12 % 7) as int;	
	var currentHour = currentTime / 60 % 12 + 8;	
	var start = window.shedule.get(currentDay).timeStart
	var end = window.shedule.get(currentDay).timeEnd

	return currentHour >=start && currentHour <= end;
}

double getDuration(Client client) {
	switch(client.service) {
			case TypeService.send_letter: {
				return send_letter_time
			}
			case TypeService.receive_letter: {
				return receive_letter_time;
			}
			case TypeService.send_delivery: {
				return send_delivery_time
			}
			case TypeService.receive_delivery: {
				return receive_delivery_time
			}
			default: {
				return serviceDuration.next();
			}
		}		
}

dataSource ServiceDuration<Double>(Window win) {
    def evaluate() {
        return win.postTime * 5;
    }
}

result operatorBusyness1 = new Result([window1.operatorState]);
result operatorBusyness2 = new Result([window2.operatorState]);
result operatorBusyness3 = new Result([window3.operatorState]);
result windowState1 = new Result([window1.windowState]);
result windowState2 = new Result([window2.windowState]);
result windowState3 = new Result([window3.windowState]);
result queue_time1 = new Result([window1.queueTimeAll/window1.servedPeopleAll], new LastValueStatistics());
result queue_time2 = new Result([window2.queueTimeAll/window2.servedPeopleAll], new LastValueStatistics());
result queue_time3 = new Result([window3.queueTimeAll/window3.servedPeopleAll], new LastValueStatistics());
result queue_time_all = new Result([(window1.queueTimeAll + window2.queueTimeAll + window3.queueTimeAll)
	/(window1.servedPeopleAll + window2.servedPeopleAll + window3.servedPeopleAll)
], new LastValueStatistics());
result serviceDuration1 = new Result(new ServiceDuration(window1));
result serviceDuration2 = new Result(new ServiceDuration(window2));
result serviceDuration3 = new Result(new ServiceDuration(window3));
result queue_length = new Result([post.queLength]);
result capacity = new Result([(window1.servedPeopleAll + window2.servedPeopleAll + window3.servedPeopleAll) /( 7 * 12 )], new LastValueStatistics());						

//______________________________________________________________________________
//Animation from Katerina =)

frame Ramochka {
    def init() {
        background = new Background(1240, 518, RaoColor.WHITE); 
    }
    def draw() {
    	
    	//Переменные для времени
    	
    	
    	//фон Анимации
    	drawImage("picpic/fon.bmp", 0, 0); 	
    	
		switch (window1.windowState) 
		{
            case (window1.windowState == WindowState.open):{           
         	drawImage("picpic/open.bmp", 245, 85);
            }
            
            case (window1.windowState == WindowState.close):{           
         	drawImage("picpic/close.bmp", 245, 180);
            }
            
            case (window1.windowState == WindowState.in_postwork):{           
         	drawImage("picpic/dopwork.bmp", 245, 250);
         	drawImage("picpic/close.bmp", 245, 180);
            }
            
		}
		
		switch (window2.windowState) 
		{
            case (window2.windowState == WindowState.open):{           
         	drawImage("picpic/open.bmp", 575, 85);
            }
            
            case (window2.windowState == WindowState.close):{           
         	drawImage("picpic/close.bmp", 575, 180);
            }
            
            case (window2.windowState == WindowState.in_postwork):{           
         	drawImage("picpic/dopwork.bmp", 575, 250);
         	drawImage("picpic/close.bmp", 575, 180);
            }
		
		}
		
			switch (window3.windowState) 
		{
            case (window3.windowState == WindowState.open):{           
         	drawImage("picpic/open.bmp", 915, 85);
            }
            
            case (window3.windowState == WindowState.close):{           
         	drawImage("picpic/close.bmp", 915, 180);
            }
            
            case (window3.windowState == WindowState.in_postwork):{           
         	drawImage("picpic/dopwork.bmp", 915, 250);
         	drawImage("picpic/close.bmp", 915, 180);
            }
		}
		//Статус "Свободен" и "Занят"
        if ((window1.operatorState == OperatorState.busy)||(window1.windowState == WindowState.close))
        {
        	drawRectangle(195, 200, 40, 20, RaoColor.RED, RaoColor.RED);
        	drawText("BUSY", 203, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        else
        {
        	drawRectangle(195, 200, 40, 20, RaoColor.GREEN, RaoColor.GREEN);
        	drawText("FREE", 203, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        
        if ((window2.operatorState == OperatorState.busy)||(window2.windowState == WindowState.close))
        {
        	drawRectangle(530, 200, 40, 20, RaoColor.RED, RaoColor.RED);
        	drawText("BUSY", 538, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        else
        {
        	drawRectangle(530, 200, 40, 20, RaoColor.GREEN, RaoColor.GREEN);
        	drawText("FREE", 538, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        
        if ((window3.operatorState == OperatorState.busy)||(window3.windowState == WindowState.close))
        {
        	drawRectangle(870, 200, 40, 20, RaoColor.RED, RaoColor.RED);
        	drawText("BUSY", 878, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        else
        {
        	drawRectangle(870, 200, 40, 20, RaoColor.GREEN, RaoColor.GREEN);
        	drawText("FREE", 878, 203, RaoColor.BLACK, 25, Alignment.LEFT);
        }
        
        //Текущее время
  //      var currentDay =  (currentTime / 60 / 12 % 7) as int;	
		var currentHour = (currentTime / 60 % 12 + 8) as int;
		var currentMinute = (currentTime % 60) as int;
        drawText(String.valueOf(currentHour), 340, 37);				//Часы
        drawText(String.valueOf(currentMinute), 400, 37);			//Минуты
        
        //Длина очереди
        drawText("Queue length", 640, 400, RaoColor.BLACK, 60, Alignment.LEFT);
        drawText(Integer.toString(post.queLength), 670, 420, RaoColor.BLACK, 30, Alignment.CENTER);
        

        //Списки сервисов
        	//Для окна №1
        drawText("Service", 365, 165);
        drawText("1. Send letter", 345, 180);
        drawText("2. Receive letter", 345, 195);
        
        	//Для окна №2
        drawText("Service", 695, 165);
        drawText("1. Send letter", 675, 180);
        drawText("2. Receive letter", 675, 195);

       		 //Для окна №3
        drawText("Service", 1035, 165);
        drawText("1. Send delivery", 1015, 180);
        drawText("2. Receive delivery", 1015, 195);
		
		
		
    }
}